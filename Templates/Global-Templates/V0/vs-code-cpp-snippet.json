{
"cp binominial coefficent": {
  "prefix": "cp_binominial_coef",
  "body": [
    "/* Binominial",
    "Usage:",
    "	1- precumpute:",
    "		InverseofNumber(mod);",
    "		InverseofFactorial(mod);",
    "		factorial(mod);",
    "*/",
    "// array to store inverse of 1 to N",
    "ll factorialNumInverse[MAX_N + 1];",
    "// array to precompute inverse of 1! to N!",
    "ll naturalNumInverse[MAX_N + 1];",
    "// array to store factorial of first N numbers",
    "ll fact[MAX_N + 1];",
    "// Function to precompute inverse of numbers",
    "void InverseofNumber(ll p)",
    "{",
    "	naturalNumInverse[0] = naturalNumInverse[1] = 1;",
    "	for (int i = 2; i <= MAX_N; i++)",
    "		naturalNumInverse[i] = naturalNumInverse[p % i] * (p - p / i) % p;",
    "}",
    "// Function to precompute inverse of factorials",
    "void InverseofFactorial(ll p)",
    "{",
    "	factorialNumInverse[0] = factorialNumInverse[1] = 1;",
    "	// precompute inverse of natural numbers",
    "	for (int i = 2; i <= MAX_N; i++)",
    "		factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p;",
    "}",
    "// Function to calculate factorial of 1 to N",
    "void factorial(ll p)",
    "{",
    "	fact[0] = 1;",
    "	// precompute factorials",
    "	for (int i = 1; i <= MAX_N; i++) {",
    "		fact[i] = (fact[i - 1] * i) % p;",
    "	}",
    "}",
    "// Function to return nCr % p in O(1) time",
    "ll Binomial(ll N, ll R, ll p)",
    "{",
    "	// n C r = n!*inverse(r!)*inverse((n-r)!)",
    "	ll ans = ((fact[N] * factorialNumInverse[R])",
    "				% p * factorialNumInverse[N - R])",
    "				% p;",
    "	return ans;",
    "}",
    ""
  ],
  "description": "cp binominial coefficent"
},
"basic segment tree for cp": {
  "prefix": "cp_segment_tree",
  "body": [
    "ll fn(ll a, ll b)",
    "{",
    "	return (a + b);",
    "}",
    "void segSetup(vector<ll> &seg, ll left, ll right, ll cur)",
    "{",
    "	if (left == right)",
    "	{",
    "		seg[cur] = 0;",
    "		return;",
    "	}",
    "	ll mid = left + (right - left) / 2;",
    "	segSetup(seg, left, mid, cur*2+1);",
    "	segSetup(seg, mid+1, right, cur*2+2);",
    "	seg[cur] = fn(seg[cur*2+1], seg[cur*2+2]);",
    "}",
    "void segUpdate(vector<ll> &seg, ll idx, ll value, ll left, ll right, ll cur)",
    "{",
    "	if (left == right)",
    "	{",
    "		if (left == idx) seg[cur] = value;",
    "		return ;",
    "	}",
    "	if (idx < left || idx > right) return ;",
    "	ll mid = left + (right - left) / 2;",
    "	segUpdate(seg, idx, value, left, mid, cur*2+1);",
    "	segUpdate(seg, idx, value, mid+1, right, cur*2+2);",
    "	seg[cur] = fn(seg[cur*2+1], seg[cur*2+2]);",
    "}",
    "ll segQuery(vector<ll> &seg, const ll &ql, const ll &qr, ll left, ll right, ll cur)",
    "{",
    "	if (ql <= left && right <= qr) return seg[cur];",
    "	if (ql > right || left > qr) return (0);",
    "	ll mid = left + (right - left) / 2;",
    "	return fn(",
    "		segQuery(seg, ql, qr, left, mid, cur*2+1),",
    "		segQuery(seg, ql, qr, mid+1, right, cur*2+2)",
    "	);",
    "}",
    ""
  ],
  "description": "basic segment tree for cp"
},
"cp single test": {
  "prefix": "cp_single_test",
  "body": [
    "/*",
    "yrhiba.github.io (c). 2022-2024",
    "*/",
    "#include <iostream>",
    "#include <vector>",
    "#include <string>",
    "#include <set>",
    "#include <map>",
    "#include <queue>",
    "#include <deque>",
    "#include <stack>",
    "#include <utility>",
    "#include <iomanip>",
    "#include <algorithm>",
    "#include <cmath>",
    "#include <climits>",
    "#include <cstdlib>",
    "#include <fstream>",
    "#include <cassert>",
    "#include <random>",
    "#include <sstream>",
    "using namespace std;",
    "# define all(x) begin(x), end(x)",
    "# define rall(x) rbegin(x), rend(x)",
    "typedef long long ll;",
    "const int mod = int(1e9 + 7);",
    "const double PI = 3.14159265359;",
    "const string directions[8] {\"D\",\"R\",\"U\",\"L\",\"DR\",\"DL\",\"TL\",\"TR\"};",
    "const int dr[8] {1, 0, -1, 0, 1, 1, -1, -1};",
    "const int dc[8] {0, 1, 0, -1, 1, -1, -1, 1};",
    "/* input - output */",
    "void setIO(string s)",
    "{",
    "	freopen((s + \".in\").c_str(), \"r\", stdin);",
    "	freopen((s + \".out\").c_str(), \"w\", stdout);",
    "}",
    "/* math */",
    "ll gcd(ll a, ll b)",
    "{",
    "	if (b == 0) return (a);",
    "	return (gcd(b, a%b));",
    "}",
    "ll lcm(ll a, ll b)",
    "{",
    "	return ((a*b)/gcd(a, b));",
    "}",
    "ll lg2(ll x)",
    "{",
    "	ll r = ((x > 0) ? 0 : 1);",
    "	while (x) x /= 2, r += 1;",
    "	return (r);",
    "}",
    "ll lg10(ll x)",
    "{",
    "	ll r = ((x > 0) ? 0 : 1);",
    "	while (x) x /= 10, r += 1;",
    "	return (r);",
    "}",
    "ll power(ll x, ll p)",
    "{",
    "	if (p == 0) return (1);",
    "	ll res = pow(x, p/2);",
    "	if (p%2) return ((res * res) * x);",
    "	return (res * res);",
    "}",
    "ll powermod(ll x, ll p, ll m = mod)",
    "{",
    "	if (p == 0) return (1);",
    "	ll res = powermod(x, p/2, m) % m;",
    "	if (p%2)",
    "		return ((((res * res) % m) * (x % m)) % m);",
    "	return ((res * res) % m);",
    "}",
    "ll inverse(ll x, ll m = mod)",
    "{",
    "	return (powermod(x, m-2, m));",
    "}",
    "/* global varibles */",
    "const int MAX_N = int(5e5);",
    "/* precalculation/setup */",
    "void preSetup()",
    "{",
    "}",
    "/* solution */",
    "void solve()",
    "{",
    "}",
    "/* main funciton */",
    "int main()",
    "{",
    "	cin.tie(0)->sync_with_stdio(0);",
    "	preSetup();",
    "	solve();",
    "	return (0);",
    "}",
    ""
  ],
  "description": "cp single test"
},
"cp multiple test": {
  "prefix": "cp_multi_test",
  "body": [
    "/*",
    "yrhiba.github.io (c). 2022-2024",
    "*/",
    "#include <iostream>",
    "#include <vector>",
    "#include <string>",
    "#include <set>",
    "#include <map>",
    "#include <queue>",
    "#include <deque>",
    "#include <stack>",
    "#include <utility>",
    "#include <iomanip>",
    "#include <algorithm>",
    "#include <cmath>",
    "#include <climits>",
    "#include <cstdlib>",
    "#include <fstream>",
    "#include <cassert>",
    "#include <random>",
    "#include <sstream>",
    "using namespace std;",
    "# define all(x) begin(x), end(x)",
    "# define rall(x) rbegin(x), rend(x)",
    "typedef long long ll;",
    "const int mod = int(1e9 + 7);",
    "const double PI = 3.14159265359;",
    "const string directions[8] {\"D\",\"R\",\"U\",\"L\",\"DR\",\"DL\",\"TL\",\"TR\"};",
    "const int dr[8] {1, 0, -1, 0, 1, 1, -1, -1};",
    "const int dc[8] {0, 1, 0, -1, 1, -1, -1, 1};",
    "/* input - output */",
    "void setIO(string s)",
    "{",
    "	freopen((s + \".in\").c_str(), \"r\", stdin);",
    "	freopen((s + \".out\").c_str(), \"w\", stdout);",
    "}",
    "/* math */",
    "ll gcd(ll a, ll b)",
    "{",
    "	if (b == 0) return (a);",
    "	return (gcd(b, a%b));",
    "}",
    "ll lcm(ll a, ll b)",
    "{",
    "	return ((a*b)/gcd(a, b));",
    "}",
    "ll lg2(ll x)",
    "{",
    "	ll r = ((x > 0) ? 0 : 1);",
    "	while (x) x /= 2, r += 1;",
    "	return (r);",
    "}",
    "ll lg10(ll x)",
    "{",
    "	ll r = ((x > 0) ? 0 : 1);",
    "	while (x) x /= 10, r += 1;",
    "	return (r);",
    "}",
    "ll power(ll x, ll p)",
    "{",
    "	if (p == 0) return (1);",
    "	ll res = pow(x, p/2);",
    "	if (p%2) return ((res * res) * x);",
    "	return (res * res);",
    "}",
    "ll powermod(ll x, ll p, ll m = mod)",
    "{",
    "	if (p == 0) return (1);",
    "	ll res = powermod(x, p/2, m) % m;",
    "	if (p%2)",
    "		return ((((res * res) % m) * (x % m)) % m);",
    "	return ((res * res) % m);",
    "}",
    "ll inverse(ll x, ll m = mod)",
    "{",
    "	return (powermod(x, m-2, m));",
    "}",
    "/* global varibles */",
    "const int MAX_N = int(5e5);",
    "/* precalculation/setup */",
    "void preSetup()",
    "{",
    "}",
    "/* solution */",
    "void solve()",
    "{",
    "}",
    "/* main funciton */",
    "int main()",
    "{",
    "	cin.tie(0)->sync_with_stdio(0);",
    "	preSetup();",
    "	ll t; cin >> t; cin.ignore();",
    "	for (ll tc = 1; tc <= t; tc++)",
    "	{",
    "		// cerr << \"test: \" << tc << \"\\n\";",
    "		solve();",
    "		// cerr << \"#####\" << \"\\n\";",
    "	}",
    "	return (0);",
    "}",
    ""
  ],
  "description": "cp multiple test"
}
}
